diff --git a/apps/BFS.C b/apps/BFS.C
index 241b8ca..84d8f8a 100644
--- a/apps/BFS.C
+++ b/apps/BFS.C
@@ -38,19 +38,23 @@ struct BFS_F {
 };
 
 template <class vertex>
-void Compute(graph<vertex>& GA, commandLine P) {
-  long start = P.getOptionLongValue("-r",0);
+long Compute(graph<vertex>& GA, long start, long max_iter) {
   long n = GA.n;
   //creates Parents array, initialized to all -1, except for start
   uintE* Parents = newA(uintE,n);
   parallel_for(long i=0;i<n;i++) Parents[i] = UINT_E_MAX;
   Parents[start] = start;
   vertexSubset Frontier(n,start); //creates initial frontier
-  while(!Frontier.isEmpty()){ //loop until frontier is empty
+
+  long round = 0;
+  while(!Frontier.isEmpty() && round < max_iter){ //loop until frontier is empty
     vertexSubset output = edgeMap(GA, Frontier, BFS_F(Parents));    
     Frontier.del();
     Frontier = output; //set new frontier
+    round++;
   } 
   Frontier.del();
   free(Parents); 
+
+  return round;
 }
diff --git a/apps/BellmanFord.C b/apps/BellmanFord.C
index 2b88a92..414611e 100644
--- a/apps/BellmanFord.C
+++ b/apps/BellmanFord.C
@@ -56,8 +56,7 @@ struct BF_Vertex_F {
 };
 
 template <class vertex>
-void Compute(graph<vertex>& GA, commandLine P) {
-  long start = P.getOptionLongValue("-r",0);
+long Compute(graph<vertex>& GA, long start, long max_iter) {
   long n = GA.n;
   //initialize ShortestPathLen to "infinity"
   intE* ShortestPathLen = newA(intE,n);
@@ -70,7 +69,7 @@ void Compute(graph<vertex>& GA, commandLine P) {
   vertexSubset Frontier(n,start); //initial frontier
 
   long round = 0;
-  while(!Frontier.isEmpty()){
+  while(!Frontier.isEmpty() && round < max_iter){
     if(round == n) {
       //negative weight cycle
       {parallel_for(long i=0;i<n;i++) ShortestPathLen[i] = -(INT_E_MAX/2);}
@@ -84,4 +83,6 @@ void Compute(graph<vertex>& GA, commandLine P) {
   }
   Frontier.del(); free(Visited);
   free(ShortestPathLen);
+
+  return round;
 }
diff --git a/apps/KCore.C b/apps/KCore.C
index 37613f7..b988d3c 100644
--- a/apps/KCore.C
+++ b/apps/KCore.C
@@ -34,7 +34,7 @@ struct Update_Deg {
     return 1;
   }
   inline bool updateAtomic (uintE s, uintE d){
-    writeAdd(&Degrees[d],-1);
+    writeAdd(&Degrees[d], static_cast<intE>(-1));
     return 1;
   }
   inline bool cond (uintE d) { return Degrees[d] > 0; }
diff --git a/apps/Makefile.m5 b/apps/Makefile.m5
new file mode 100644
index 0000000..d064e00
--- /dev/null
+++ b/apps/Makefile.m5
@@ -0,0 +1,87 @@
+CXX = g++
+CXXFLAGS  = -std=c++14 -O3
+LDFLAGS =
+LIBS    = 
+SUFFIX  :=
+
+MACROS =
+
+ifdef PD
+  CXXFLAGS += -DPD
+endif
+
+ifdef BYTE
+  CXXFLAGS += -DBYTE
+else ifdef NIBBLE
+  CXXFLAGS += -DNIBBLE
+else
+  CXXFLAGS += -DBYTERLE
+endif
+
+ifdef LOWMEM
+  CXXFLAGS += -DLOWMEM
+endif
+
+ifdef OPENMP
+  CXXFLAGS += -DOPENMP=1
+  LDFLAGS += -fopenmp
+  SUFFIX := $(SUFFIX)-omp
+endif
+
+ifdef STATIC
+  LDFLAGS += -static
+  SUFFIX := $(SUFFIX)-static
+endif
+
+ifneq ($(MARCH),)
+  CXXFLAGS += -march=$(MARCH)
+endif
+
+ifneq ($(M5_PREFIX),)
+  MACROS += -DUSEM5OPS
+  CXXFLAGS += -I$(M5_PREFIX)/include -L$(M5_PREFIX)/lib
+  LIBS   += -lm5
+  SUFFIX := $(SUFFIX)-m5
+endif
+
+ifneq ($(LK_PREFIX),)
+  MACROS += -DLIKWID_PERFMON
+  CXXFLAGS += -I$(LK_PREFIX)/include -L$(LK_PREFIX)/lib
+  LIBS   += -llikwid
+  SUFFIX := $(SUFFIX)-lk
+endif
+
+MACROS += -D__COMPILE_COMMAND__="\"$(CXX) $(CXXFLAGS) $(LDFLAGS) $(LIBS)\""
+
+COMMON = ligra.h timer.hpp graph.h compressedVertex.h vertex.h utils.h IO.h parallel.h gettime.h index_map.h maybe.h sequence.h edgeMap_utils.h binary_search.h quickSort.h blockRadixSort.h transpose.h parseCommandLine.h byte.h byteRLE.h nibble.h byte-pd.h byteRLE-pd.h nibble-pd.h vertexSubset.h encoder.C decoder.C
+
+KERNELS = ligra-bfs_32 ligra-bfs_64 ligra-sssp_32 ligra-sssp_64
+
+ALL = $(addsuffix $(SUFFIX).x,$(KERNELS))
+
+all: $(ALL)
+
+ligra-bfs_32%: BFS.C $(COMMON)
+	$(CXX) $(CXXFLAGS) $(LDFLAGS) $(MACROS)  $< $(LIBS) -o $@
+
+ligra-bfs_64%: BFS.C $(COMMON)
+	$(CXX) $(CXXFLAGS) -DLONG -DEDGELONG $(LDFLAGS) $(MACROS)  $< $(LIBS) -o $@
+
+ligra-sssp_32%: BellmanFord.C $(COMMON)
+	$(CXX) $(CXXFLAGS) $(LDFLAGS) $(MACROS)  $< $(LIBS) -o $@
+
+ligra-sssp_64%: BellmanFord.C $(COMMON)
+	$(CXX) $(CXXFLAGS) -DLONG -DEDGELONG $(LDFLAGS) $(MACROS)  $< $(LIBS) -o $@
+
+
+$(COMMON):
+	ln -s ../ligra/$@ .
+
+.PHONY : clean
+
+clean :
+	rm -f *.o $(ALL)
+
+cleansrc :
+	rm -f *.o $(ALL)
+	rm $(COMMON)
diff --git a/ligra/IO.h b/ligra/IO.h
index e31dfc6..f7437df 100644
--- a/ligra/IO.h
+++ b/ligra/IO.h
@@ -181,23 +181,27 @@ graph<vertex> readGraphFromFile(char* fname, bool isSymmetric, bool mmap) {
     W = stringToWords(S.A, S.n);
   }
 #ifndef WEIGHTED
-  if (W.Strings[0] != (string) "AdjacencyGraph") {
+  if ( !( W.Strings[0] == (string) "AdjacencyGraph"
+       || W.Strings[0] == (string) "WeightedAdjacencyGraph")) {
 #else
   if (W.Strings[0] != (string) "WeightedAdjacencyGraph") {
 #endif
-    cout << "Bad input file" << endl;
+    cout << "Bad input file: \"" << W.Strings[0] << "\"" << endl;
     abort();
   }
 
-  long len = W.m -1;
   long n = atol(W.Strings[1]);
   long m = atol(W.Strings[2]);
 #ifndef WEIGHTED
+  long len = W.m -1;
+  //ignore extra weight lines
+  if (W.Strings[0] == (string) "WeightedAdjacencyGraph") len -= m;
   if (len != n + m + 2) {
 #else
+  long len = W.m -1;
   if (len != n + 2*m + 2) {
 #endif
-    cout << "Bad input file" << endl;
+    cout << "Bad input file len=" << len << " W.m=" << W.m << " n=" << n << " m=" << m << endl;
     abort();
   }
 
diff --git a/ligra/encoder.C b/ligra/encoder.C
index c8fa677..00ddc4b 100644
--- a/ligra/encoder.C
+++ b/ligra/encoder.C
@@ -70,7 +70,7 @@ void logCost(uintT* offsets, uintE* edges, long n, long m, uintE* Degrees){
   parallel_for(long i=0;i<n;i++) {
     long o = offsets[i];
     for(long j=0;j<Degrees[i];j++) {
-      logs[i] += log((double) abs(edges[o+j]-i) + 1);
+      logs[i] += log((double) abs(static_cast<long>(edges[o+j]-i)) + 1);
     }
   }
   cout << "log cost = " << 
@@ -86,7 +86,7 @@ void gapCost(uintT* offsets, uintE* edges, long n, long m, uintE* Degrees){
     long o = offsets[i];
     long d = Degrees[i];
     if(d > 0) {
-      logs[i] += log((double) abs(i-edges[o]) + 1);
+      logs[i] += log((double) abs(static_cast<long>(i-edges[o])) + 1);
       for(long j=1;j<d;j++) {
 	logs[i] += log((double) abs((long)edges[o+j]-(long)edges[o+j-1]) + 1);
       }
diff --git a/ligra/ligra.h b/ligra/ligra.h
index c78d5a0..6ba0263 100644
--- a/ligra/ligra.h
+++ b/ligra/ligra.h
@@ -1,5 +1,5 @@
 // This code is part of the project "Ligra: A Lightweight Graph Processing
-// Framework for Shared Memory", presented at Principles and Practice of 
+// Framework for Shared Memory", presented at Principles and Practice of
 // Parallel Programming, 2013.
 // Copyright (c) 2013 Julian Shun and Guy Blelloch
 //
@@ -29,6 +29,7 @@
 #include <cstring>
 #include <string>
 #include <algorithm>
+#include <vector>
 #include "parallel.h"
 #include "gettime.h"
 #include "utils.h"
@@ -40,6 +41,15 @@
 #include "parseCommandLine.h"
 #include "index_map.h"
 #include "edgeMap_utils.h"
+#include "timer.hpp"
+
+#ifdef USEM5OPS
+#include <gem5/m5ops.h>
+#endif
+#ifdef LIKWID_PERFMON
+#include <likwid-marker.h>
+#endif
+
 using namespace std;
 
 //*****START FRAMEWORK*****
@@ -53,27 +63,35 @@ const flags dense_parallel = 16;
 const flags remove_duplicates = 32;
 const flags no_dense = 64;
 const flags edge_parallel = 128;
-inline bool should_output(const flags& fl) { return !(fl & no_output); }
+inline bool should_output(const flags &fl) { return !(fl & no_output); }
 
 template <class data, class vertex, class VS, class F>
-vertexSubsetData<data> edgeMapDense(graph<vertex> GA, VS& vertexSubset, F &f, const flags fl) {
+vertexSubsetData<data> edgeMapDense(graph<vertex> GA, VS &vertexSubset, F &f, const flags fl)
+{
   using D = tuple<bool, data>;
   long n = GA.n;
   vertex *G = GA.V;
-  if (should_output(fl)) {
-    D* next = newA(D, n);
+  if (should_output(fl))
+  {
+    D *next = newA(D, n);
     auto g = get_emdense_gen<data>(next);
-    parallel_for (long v=0; v<n; v++) {
+    parallel_for(long v = 0; v < n; v++)
+    {
       std::get<0>(next[v]) = 0;
-      if (f.cond(v)) {
+      if (f.cond(v))
+      {
         G[v].decodeInNghBreakEarly(v, vertexSubset, f, g, fl & dense_parallel);
       }
     }
     return vertexSubsetData<data>(n, next);
-  } else {
+  }
+  else
+  {
     auto g = get_emdense_nooutput_gen<data>();
-    parallel_for (long v=0; v<n; v++) {
-      if (f.cond(v)) {
+    parallel_for(long v = 0; v < n; v++)
+    {
+      if (f.cond(v))
+      {
         G[v].decodeInNghBreakEarly(v, vertexSubset, f, g, fl & dense_parallel);
       }
     }
@@ -82,24 +100,32 @@ vertexSubsetData<data> edgeMapDense(graph<vertex> GA, VS& vertexSubset, F &f, co
 }
 
 template <class data, class vertex, class VS, class F>
-vertexSubsetData<data> edgeMapDenseForward(graph<vertex> GA, VS& vertexSubset, F &f, const flags fl) {
+vertexSubsetData<data> edgeMapDenseForward(graph<vertex> GA, VS &vertexSubset, F &f, const flags fl)
+{
   using D = tuple<bool, data>;
   long n = GA.n;
   vertex *G = GA.V;
-  if (should_output(fl)) {
-    D* next = newA(D, n);
+  if (should_output(fl))
+  {
+    D *next = newA(D, n);
     auto g = get_emdense_forward_gen<data>(next);
-    parallel_for(long i=0;i<n;i++) { std::get<0>(next[i]) = 0; }
-    parallel_for (long i=0; i<n; i++) {
-      if (vertexSubset.isIn(i)) {
+    parallel_for(long i = 0; i < n; i++) { std::get<0>(next[i]) = 0; }
+    parallel_for(long i = 0; i < n; i++)
+    {
+      if (vertexSubset.isIn(i))
+      {
         G[i].decodeOutNgh(i, f, g);
       }
     }
     return vertexSubsetData<data>(n, next);
-  } else {
+  }
+  else
+  {
     auto g = get_emdense_forward_nooutput_gen<data>();
-    parallel_for (long i=0; i<n; i++) {
-      if (vertexSubset.isIn(i)) {
+    parallel_for(long i = 0; i < n; i++)
+    {
+      if (vertexSubset.isIn(i))
+      {
         G[i].decodeOutNgh(i, f, g);
       }
     }
@@ -108,59 +134,73 @@ vertexSubsetData<data> edgeMapDenseForward(graph<vertex> GA, VS& vertexSubset, F
 }
 
 template <class data, class vertex, class VS, class F>
-vertexSubsetData<data> edgeMapSparse(graph<vertex>& GA, vertex* frontierVertices, VS& indices,
-        uintT* degrees, uintT m, F &f, const flags fl) {
+vertexSubsetData<data> edgeMapSparse(graph<vertex> &GA, vertex *frontierVertices, VS &indices,
+                                     uintT *degrees, uintT m, F &f, const flags fl)
+{
   using S = tuple<uintE, data>;
   long n = indices.n;
-  S* outEdges;
+  S *outEdges;
   long outEdgeCount = 0;
 
-  if (should_output(fl)) {
-    uintT* offsets = degrees;
+  if (should_output(fl))
+  {
+    uintT *offsets = degrees;
     outEdgeCount = sequence::plusScan(offsets, offsets, m);
     outEdges = newA(S, outEdgeCount);
     auto g = get_emsparse_gen<data>(outEdges);
-    parallel_for (size_t i = 0; i < m; i++) {
+    parallel_for(size_t i = 0; i < m; i++)
+    {
       uintT v = indices.vtx(i), o = offsets[i];
       vertex vert = frontierVertices[i];
       vert.decodeOutNghSparse(v, o, f, g);
     }
-  } else {
+  }
+  else
+  {
     auto g = get_emsparse_nooutput_gen<data>();
-    parallel_for (size_t i = 0; i < m; i++) {
+    parallel_for(size_t i = 0; i < m; i++)
+    {
       uintT v = indices.vtx(i);
       vertex vert = frontierVertices[i];
       vert.decodeOutNghSparse(v, 0, f, g);
     }
   }
 
-  if (should_output(fl)) {
-    S* nextIndices = newA(S, outEdgeCount);
-    if (fl & remove_duplicates) {
-      if (GA.flags == NULL) {
+  if (should_output(fl))
+  {
+    S *nextIndices = newA(S, outEdgeCount);
+    if (fl & remove_duplicates)
+    {
+      if (GA.flags == NULL)
+      {
         GA.flags = newA(uintE, n);
-        parallel_for(long i=0;i<n;i++) { GA.flags[i]=UINT_E_MAX; }
+        parallel_for(long i = 0; i < n; i++) { GA.flags[i] = UINT_E_MAX; }
       }
-      auto get_key = [&] (size_t i) -> uintE& { return std::get<0>(outEdges[i]); };
+      auto get_key = [&](size_t i) -> uintE &
+      { return std::get<0>(outEdges[i]); };
       remDuplicates(get_key, GA.flags, outEdgeCount, n);
     }
-    auto p = [] (tuple<uintE, data>& v) { return std::get<0>(v) != UINT_E_MAX; };
+    auto p = [](tuple<uintE, data> &v)
+    { return std::get<0>(v) != UINT_E_MAX; };
     size_t nextM = pbbs::filterf(outEdges, nextIndices, outEdgeCount, p);
     free(outEdges);
     return vertexSubsetData<data>(n, nextM, nextIndices);
-  } else {
+  }
+  else
+  {
     return vertexSubsetData<data>(n);
   }
 }
 
 template <class data, class vertex, class VS, class F>
-vertexSubsetData<data> edgeMapSparse_no_filter(graph<vertex>& GA,
-    vertex* frontierVertices, VS& indices, uintT* offsets, uintT m, F& f,
-    const flags fl) {
+vertexSubsetData<data> edgeMapSparse_no_filter(graph<vertex> &GA,
+                                               vertex *frontierVertices, VS &indices, uintT *offsets, uintT m, F &f,
+                                               const flags fl)
+{
   using S = tuple<uintE, data>;
   long n = indices.n;
   long outEdgeCount = sequence::plusScan(offsets, offsets, m);
-  S* outEdges = newA(S, outEdgeCount);
+  S *outEdges = newA(S, outEdgeCount);
 
   auto g = get_emsparse_no_filter_gen<data>(outEdges);
 
@@ -168,30 +208,38 @@ vertexSubsetData<data> edgeMapSparse_no_filter(graph<vertex>& GA,
   size_t b_size = 10000;
   size_t n_blocks = nblocks(outEdgeCount, b_size);
 
-  uintE* cts = newA(uintE, n_blocks+1);
-  size_t* block_offs = newA(size_t, n_blocks+1);
+  uintE *cts = newA(uintE, n_blocks + 1);
+  size_t *block_offs = newA(size_t, n_blocks + 1);
 
-  auto offsets_m = make_in_imap<uintT>(m, [&] (size_t i) { return offsets[i]; });
-  auto lt = [] (const uintT& l, const uintT& r) { return l < r; };
-  parallel_for(size_t i=0; i<n_blocks; i++) {
-    size_t s_val = i*b_size;
+  auto offsets_m = make_in_imap<uintT>(m, [&](size_t i)
+                                       { return offsets[i]; });
+  auto lt = [](const uintT &l, const uintT &r)
+  { return l < r; };
+  parallel_for(size_t i = 0; i < n_blocks; i++)
+  {
+    size_t s_val = i * b_size;
     block_offs[i] = pbbs::binary_search(offsets_m, s_val, lt);
   }
   block_offs[n_blocks] = m;
-  parallel_for (size_t i=0; i<n_blocks; i++) {
-    if ((i == n_blocks-1) || block_offs[i] != block_offs[i+1]) {
+  parallel_for(size_t i = 0; i < n_blocks; i++)
+  {
+    if ((i == n_blocks - 1) || block_offs[i] != block_offs[i + 1])
+    {
       // start and end are offsets in [m]
       size_t start = block_offs[i];
-      size_t end = block_offs[i+1];
+      size_t end = block_offs[i + 1];
       uintT start_o = offsets[start];
       uintT k = start_o;
-      for (size_t j=start; j<end; j++) {
+      for (size_t j = start; j < end; j++)
+      {
         uintE v = indices.vtx(j);
         size_t num_in = frontierVertices[j].decodeOutNghSparseSeq(v, k, f, g);
         k += num_in;
       }
       cts[i] = (k - start_o);
-    } else {
+    }
+    else
+    {
       cts[i] = 0;
     }
   }
@@ -199,30 +247,39 @@ vertexSubsetData<data> edgeMapSparse_no_filter(graph<vertex>& GA,
   long outSize = sequence::plusScan(cts, cts, n_blocks);
   cts[n_blocks] = outSize;
 
-  S* out = newA(S, outSize);
+  S *out = newA(S, outSize);
 
-  parallel_for (size_t i=0; i<n_blocks; i++) {
-    if ((i == n_blocks-1) || block_offs[i] != block_offs[i+1]) {
+  parallel_for(size_t i = 0; i < n_blocks; i++)
+  {
+    if ((i == n_blocks - 1) || block_offs[i] != block_offs[i + 1])
+    {
       size_t start = block_offs[i];
       size_t start_o = offsets[start];
       size_t out_off = cts[i];
-      size_t block_size = cts[i+1] - out_off;
-      for (size_t j=0; j<block_size; j++) {
+      size_t block_size = cts[i + 1] - out_off;
+      for (size_t j = 0; j < block_size; j++)
+      {
         out[out_off + j] = outEdges[start_o + j];
       }
     }
   }
-  free(outEdges); free(cts); free(block_offs);
-
-  if (fl & remove_duplicates) {
-    if (GA.flags == NULL) {
+  free(outEdges);
+  free(cts);
+  free(block_offs);
+
+  if (fl & remove_duplicates)
+  {
+    if (GA.flags == NULL)
+    {
       GA.flags = newA(uintE, n);
-      parallel_for(size_t i=0;i<n;i++) { GA.flags[i]=UINT_E_MAX; }
+      parallel_for(size_t i = 0; i < n; i++) { GA.flags[i] = UINT_E_MAX; }
     }
-    auto get_key = [&] (size_t i) -> uintE& { return std::get<0>(out[i]); };
+    auto get_key = [&](size_t i) -> uintE &
+    { return std::get<0>(out[i]); };
     remDuplicates(get_key, GA.flags, outSize, n);
-    S* nextIndices = newA(S, outSize);
-    auto p = [] (tuple<uintE, data>& v) { return std::get<0>(v) != UINT_E_MAX; };
+    S *nextIndices = newA(S, outSize);
+    auto p = [](tuple<uintE, data> &v)
+    { return std::get<0>(v) != UINT_E_MAX; };
     size_t nextM = pbbs::filterf(out, nextIndices, outSize, p);
     free(out);
     return vertexSubsetData<data>(n, nextM, nextIndices);
@@ -232,53 +289,67 @@ vertexSubsetData<data> edgeMapSparse_no_filter(graph<vertex>& GA,
 
 // Decides on sparse or dense base on number of nonzeros in the active vertices.
 template <class data, class vertex, class VS, class F>
-vertexSubsetData<data> edgeMapData(graph<vertex>& GA, VS &vs, F f,
-    intT threshold = -1, const flags& fl=0) {
+vertexSubsetData<data> edgeMapData(graph<vertex> &GA, VS &vs, F f,
+                                   intT threshold = -1, const flags &fl = 0)
+{
   long numVertices = GA.n, numEdges = GA.m, m = vs.numNonzeros();
-  if(threshold == -1) threshold = numEdges/20; //default threshold
+  if (threshold == -1)
+    threshold = numEdges / 20; // default threshold
   vertex *G = GA.V;
-  if (numVertices != vs.numRows()) {
+  if (numVertices != vs.numRows())
+  {
     cout << "edgeMap: Sizes Don't match" << endl;
     abort();
   }
-  if (m == 0) return vertexSubsetData<data>(numVertices);
-  uintT* degrees = NULL;
-  vertex* frontierVertices = NULL;
+  if (m == 0)
+    return vertexSubsetData<data>(numVertices);
+  uintT *degrees = NULL;
+  vertex *frontierVertices = NULL;
   uintT outDegrees = 0;
-  if((fl & no_dense) || threshold > 0) { //compute sum of out-degrees if threshold > 0 
+  if((fl & no_dense) || threshold > 0)
+  { // compute sum of out-degrees if threshold > 0
     vs.toSparse();
     degrees = newA(uintT, m);
-    frontierVertices = newA(vertex,m);
-    {parallel_for (size_t i=0; i < m; i++) {
-	uintE v_id = vs.vtx(i);
-	vertex v = G[v_id];
-	degrees[i] = v.getOutDegree();
-	frontierVertices[i] = v;
-      }}
+    frontierVertices = newA(vertex, m);
+    {
+      parallel_for(size_t i = 0; i < m; i++)
+      {
+        uintE v_id = vs.vtx(i);
+        vertex v = G[v_id];
+        degrees[i] = v.getOutDegree();
+        frontierVertices[i] = v;
+      }
+    }
     outDegrees = sequence::plusReduce(degrees, m);
-    if (outDegrees == 0) return vertexSubsetData<data>(numVertices);
+    if (outDegrees == 0)
+      return vertexSubsetData<data>(numVertices);
   }
-  if (!(fl & no_dense) && m + outDegrees > threshold) {
-    if(degrees) free(degrees);
-    if(frontierVertices) free(frontierVertices);
+  if (!(fl & no_dense) && m + outDegrees > threshold)
+  {
+    if (degrees)
+      free(degrees);
+    if (frontierVertices)
+      free(frontierVertices);
     vs.toDense();
-    return (fl & dense_forward) ?
-      edgeMapDenseForward<data, vertex, VS, F>(GA, vs, f, fl) :
-      edgeMapDense<data, vertex, VS, F>(GA, vs, f, fl);
-  } else {
+    return (fl & dense_forward) ? edgeMapDenseForward<data, vertex, VS, F>(GA, vs, f, fl) : edgeMapDense<data, vertex, VS, F>(GA, vs, f, fl);
+  }
+  else
+  {
     auto vs_out =
-      (should_output(fl) && fl & sparse_no_filter) ? // only call snof when we output
-      edgeMapSparse_no_filter<data, vertex, VS, F>(GA, frontierVertices, vs, degrees, vs.numNonzeros(), f, fl) :
-      edgeMapSparse<data, vertex, VS, F>(GA, frontierVertices, vs, degrees, vs.numNonzeros(), f, fl);
-    free(degrees); free(frontierVertices);
+        (should_output(fl) && fl & sparse_no_filter) ? // only call snof when we output
+            edgeMapSparse_no_filter<data, vertex, VS, F>(GA, frontierVertices, vs, degrees, vs.numNonzeros(), f, fl)
+                                                     : edgeMapSparse<data, vertex, VS, F>(GA, frontierVertices, vs, degrees, vs.numNonzeros(), f, fl);
+    free(degrees);
+    free(frontierVertices);
     return vs_out;
   }
 }
 
 // Regular edgeMap, where no extra data is stored per vertex.
 template <class vertex, class VS, class F>
-vertexSubset edgeMap(graph<vertex>& GA, VS& vs, F f,
-    intT threshold = -1, const flags& fl=0) {
+vertexSubset edgeMap(graph<vertex> &GA, VS &vs, F f,
+                     intT threshold = -1, const flags &fl = 0)
+{
   return edgeMapData<pbbs::empty>(GA, vs, f, threshold, fl);
 }
 
@@ -286,11 +357,15 @@ vertexSubset edgeMap(graph<vertex>& GA, VS& vs, F f,
 // in the new adjacency list if p(ngh) is true.
 // Weighted graphs are not yet supported, but this should be easy to do.
 template <class vertex, class P>
-vertexSubsetData<uintE> packEdges(graph<vertex>& GA, vertexSubset& vs, P& p, const flags& fl=0) {
+vertexSubsetData<uintE> packEdges(graph<vertex> &GA, vertexSubset &vs, P &p, const flags &fl = 0)
+{
   using S = tuple<uintE, uintE>;
   vs.toSparse();
-  vertex* G = GA.V; long m = vs.numNonzeros(); long n = vs.numRows();
-  if (vs.size() == 0) {
+  vertex *G = GA.V;
+  long m = vs.numNonzeros();
+  long n = vs.numRows();
+  if (vs.size() == 0)
+  {
     return vertexSubsetData<uintE>(n);
   }
   auto degrees = array_imap<uintT>(m);
@@ -299,139 +374,187 @@ vertexSubsetData<uintE> packEdges(graph<vertex>& GA, vertexSubset& vs, P& p, con
     degrees[i] = G[v].getOutDegree();
   });
   long outEdgeCount = pbbs::scan_add(degrees, degrees);
-  S* outV;
-  if (should_output(fl)) {
+  S *outV;
+  if (should_output(fl))
+  {
     outV = newA(S, vs.size());
   }
 
-  bool* bits = newA(bool, outEdgeCount);
-  uintE* tmp1 = newA(uintE, outEdgeCount);
-  uintE* tmp2 = newA(uintE, outEdgeCount);
-  if (should_output(fl)) {
-    parallel_for (size_t i=0; i<m; i++) {
+  bool *bits = newA(bool, outEdgeCount);
+  uintE *tmp1 = newA(uintE, outEdgeCount);
+  uintE *tmp2 = newA(uintE, outEdgeCount);
+  if (should_output(fl))
+  {
+    parallel_for(size_t i = 0; i < m; i++)
+    {
       uintE v = vs.vtx(i);
       size_t offset = degrees[i];
-      auto bitsOff = &(bits[offset]); auto tmp1Off = &(tmp1[offset]);
+      auto bitsOff = &(bits[offset]);
+      auto tmp1Off = &(tmp1[offset]);
       auto tmp2Off = &(tmp2[offset]);
       size_t ct = G[v].packOutNgh(v, p, bitsOff, tmp1Off, tmp2Off);
       outV[i] = make_tuple(v, ct);
     }
-  } else {
-    parallel_for (size_t i=0; i<m; i++) {
+  }
+  else
+  {
+    parallel_for(size_t i = 0; i < m; i++)
+    {
       uintE v = vs.vtx(i);
       size_t offset = degrees[i];
-      auto bitsOff = &(bits[offset]); auto tmp1Off = &(tmp1[offset]);
+      auto bitsOff = &(bits[offset]);
+      auto tmp1Off = &(tmp1[offset]);
       auto tmp2Off = &(tmp2[offset]);
       size_t ct = G[v].packOutNgh(v, p, bitsOff, tmp1Off, tmp2Off);
     }
   }
-  free(bits); free(tmp1); free(tmp2);
-  if (should_output(fl)) {
+  free(bits);
+  free(tmp1);
+  free(tmp2);
+  if (should_output(fl))
+  {
     return vertexSubsetData<uintE>(n, m, outV);
-  } else {
+  }
+  else
+  {
     return vertexSubsetData<uintE>(n);
   }
 }
 
 template <class vertex, class P>
-vertexSubsetData<uintE> edgeMapFilter(graph<vertex>& GA, vertexSubset& vs, P& p, const flags& fl=0) {
+vertexSubsetData<uintE> edgeMapFilter(graph<vertex> &GA, vertexSubset &vs, P &p, const flags &fl = 0)
+{
   vs.toSparse();
-  if (fl & pack_edges) {
+  if (fl & pack_edges)
+  {
     return packEdges<vertex, P>(GA, vs, p, fl);
   }
-  vertex* G = GA.V; long m = vs.numNonzeros(); long n = vs.numRows();
+  vertex *G = GA.V;
+  long m = vs.numNonzeros();
+  long n = vs.numRows();
   using S = tuple<uintE, uintE>;
-  if (vs.size() == 0) {
+  if (vs.size() == 0)
+  {
     return vertexSubsetData<uintE>(n);
   }
-  S* outV;
-  if (should_output(fl)) {
+  S *outV;
+  if (should_output(fl))
+  {
     outV = newA(S, vs.size());
   }
-  if (should_output(fl)) {
-    parallel_for (size_t i=0; i<m; i++) {
+  if (should_output(fl))
+  {
+    parallel_for(size_t i = 0; i < m; i++)
+    {
       uintE v = vs.vtx(i);
       size_t ct = G[v].countOutNgh(v, p);
       outV[i] = make_tuple(v, ct);
     }
-  } else {
-    parallel_for (size_t i=0; i<m; i++) {
+  }
+  else
+  {
+    parallel_for(size_t i = 0; i < m; i++)
+    {
       uintE v = vs.vtx(i);
       size_t ct = G[v].countOutNgh(v, p);
     }
   }
-  if (should_output(fl)) {
+  if (should_output(fl))
+  {
     return vertexSubsetData<uintE>(n, m, outV);
-  } else {
+  }
+  else
+  {
     return vertexSubsetData<uintE>(n);
   }
 }
 
-
-
 //*****VERTEX FUNCTIONS*****
 
-template <class F, class VS, typename std::enable_if<
-  !std::is_same<VS, vertexSubset>::value, int>::type=0 >
-void vertexMap(VS& V, F f) {
+template <class F, class VS, typename std::enable_if<!std::is_same<VS, vertexSubset>::value, int>::type = 0>
+void vertexMap(VS &V, F f)
+{
   size_t n = V.numRows(), m = V.numNonzeros();
-  if(V.dense()) {
-    parallel_for(long i=0;i<n;i++) {
-      if(V.isIn(i)) {
+  if (V.dense())
+  {
+    parallel_for(long i = 0; i < n; i++)
+    {
+      if (V.isIn(i))
+      {
         f(i, V.ithData(i));
       }
     }
-  } else {
-    parallel_for(long i=0;i<m;i++) {
+  }
+  else
+  {
+    parallel_for(long i = 0; i < m; i++)
+    {
       f(V.vtx(i), V.vtxData(i));
     }
   }
 }
 
-template <class VS, class F, typename std::enable_if<
-  std::is_same<VS, vertexSubset>::value, int>::type=0 >
-void vertexMap(VS& V, F f) {
+template <class VS, class F, typename std::enable_if<std::is_same<VS, vertexSubset>::value, int>::type = 0>
+void vertexMap(VS &V, F f)
+{
   size_t n = V.numRows(), m = V.numNonzeros();
-  if(V.dense()) {
-    parallel_for(long i=0;i<n;i++) {
-      if(V.isIn(i)) {
+  if (V.dense())
+  {
+    parallel_for(long i = 0; i < n; i++)
+    {
+      if (V.isIn(i))
+      {
         f(i);
       }
     }
-  } else {
-    parallel_for(long i=0;i<m;i++) {
+  }
+  else
+  {
+    parallel_for(long i = 0; i < m; i++)
+    {
       f(V.vtx(i));
     }
   }
 }
 
-//Note: this is the version of vertexMap in which only a subset of the
-//input vertexSubset is returned
+// Note: this is the version of vertexMap in which only a subset of the
+// input vertexSubset is returned
 template <class F>
-vertexSubset vertexFilter(vertexSubset V, F filter) {
+vertexSubset vertexFilter(vertexSubset V, F filter)
+{
   long n = V.numRows(), m = V.numNonzeros();
   V.toDense();
-  bool* d_out = newA(bool,n);
-  {parallel_for(long i=0;i<n;i++) d_out[i] = 0;}
-  {parallel_for(long i=0;i<n;i++)
-      if(V.d[i]) d_out[i] = filter(i);}
-  return vertexSubset(n,d_out);
+  bool *d_out = newA(bool, n);
+  {
+    parallel_for(long i = 0; i < n; i++) d_out[i] = 0;
+  }
+  {
+    parallel_for(long i = 0; i < n; i++) if (V.d[i]) d_out[i] = filter(i);
+  }
+  return vertexSubset(n, d_out);
 }
 
 template <class F>
-vertexSubset vertexFilter2(vertexSubset V, F filter) {
+vertexSubset vertexFilter2(vertexSubset V, F filter)
+{
   long n = V.numRows(), m = V.numNonzeros();
-  if (m == 0) {
+  if (m == 0)
+  {
     return vertexSubset(n);
   }
-  bool* bits = newA(bool, m);
+  bool *bits = newA(bool, m);
   V.toSparse();
-  {parallel_for(size_t i=0; i<m; i++) {
-    uintE v = V.vtx(i);
-    bits[i] = filter(v);
-  }}
-  auto v_imap = make_in_imap<uintE>(m, [&] (size_t i) { return V.vtx(i); });
-  auto bits_m = make_in_imap<bool>(m, [&] (size_t i) { return bits[i]; });
+  {
+    parallel_for(size_t i = 0; i < m; i++)
+    {
+      uintE v = V.vtx(i);
+      bits[i] = filter(v);
+    }
+  }
+  auto v_imap = make_in_imap<uintE>(m, [&](size_t i)
+                                    { return V.vtx(i); });
+  auto bits_m = make_in_imap<bool>(m, [&](size_t i)
+                                   { return bits[i]; });
   auto out = pbbs::pack(v_imap, bits_m);
   out.alloc = false;
   free(bits);
@@ -439,113 +562,264 @@ vertexSubset vertexFilter2(vertexSubset V, F filter) {
 }
 
 template <class data, class F>
-vertexSubset vertexFilter2(vertexSubsetData<data> V, F filter) {
+vertexSubset vertexFilter2(vertexSubsetData<data> V, F filter)
+{
   long n = V.numRows(), m = V.numNonzeros();
-  if (m == 0) {
+  if (m == 0)
+  {
     return vertexSubset(n);
   }
-  bool* bits = newA(bool, m);
+  bool *bits = newA(bool, m);
   V.toSparse();
-  parallel_for(size_t i=0; i<m; i++) {
+  parallel_for(size_t i = 0; i < m; i++)
+  {
     auto t = V.vtxAndData(i);
     bits[i] = filter(std::get<0>(t), std::get<1>(t));
   }
-  auto v_imap = make_in_imap<uintE>(m, [&] (size_t i) { return V.vtx(i); });
-  auto bits_m = make_in_imap<bool>(m, [&] (size_t i) { return bits[i]; });
+  auto v_imap = make_in_imap<uintE>(m, [&](size_t i)
+                                    { return V.vtx(i); });
+  auto bits_m = make_in_imap<bool>(m, [&](size_t i)
+                                   { return bits[i]; });
   auto out = pbbs::pack(v_imap, bits_m);
   out.alloc = false;
   free(bits);
   return vertexSubset(n, out.size(), out.s);
 }
 
+// cond function that always returns true
+inline bool cond_true(intT d) { return 1; }
 
+template <class vertex>
+void Compute(graph<vertex> &, commandLine);
 
-//cond function that always returns true
-inline bool cond_true (intT d) { return 1; }
+template <class vertex>
+void Compute(graph<vertex> &, long root);
 
-template<class vertex>
-void Compute(graph<vertex>&, commandLine);
+template <class vertex>
+void Compute(hypergraph<vertex> &, commandLine);
 
-template<class vertex>
-void Compute(hypergraph<vertex>&, commandLine);
+template <class vertex>
+long Compute(graph<vertex> &, long root, long max_iter);
+
+std::vector<long> read_roots_from_file(const std::string &path)
+{
+  std::vector<long> vec;
+  std::ifstream file(path);
+  long elem;
+  while (file >> elem)
+    vec.push_back(elem);
+  file.close();
+
+  return vec;
+}
 
-int parallel_main(int argc, char* argv[]) {
-  commandLine P(argc,argv," [-s] <inFile>");
-  char* iFile = P.getArgument(0);
+int parallel_main(int argc, char *argv[])
+{
+  commandLine P(argc, argv, " [-s] <inFile>");
+  struct timespec t0, t1;
+  vec500::benchmarks::Timer<long long> timer;
+  char *iFile = P.getArgument(0);
+  char *rFile = P.getArgument(1);
+  auto roots = read_roots_from_file(std::string(rFile));
   bool symmetric = P.getOptionValue("-s");
   bool compressed = P.getOptionValue("-c");
   bool binary = P.getOptionValue("-b");
   bool mmap = P.getOptionValue("-m");
-  //cout << "mmap = " << mmap << endl;
-  long rounds = P.getOptionLongValue("-rounds",3);
-  if (compressed) {
-    if (symmetric) {
+  // cout << "mmap = " << mmap << endl;
+  long nroots = P.getOptionLongValue("-nroots", roots.size());
+  long rounds = P.getOptionLongValue("-rounds", 1);
+  long max_iter = P.getOptionLongValue("-maxiter", 50);
+  long warmup = P.getOptionLongValue("-warmup", 0);
+  long root_v = P.getOptionLongValue("-rootv", 0);
+  double clock = P.getOptionDoubleValue("-clock", 0.0);
+  long conv_iter = 0;
+
+  if (0 < root_v && root_v < roots.size()) {
+    nroots = 1;
+    roots[0] = roots[root_v];
+  }
+
+#ifdef _OPENMP
+  const int nthreads = omp_get_max_threads();
+#else
+  const int nthreads = 1;
+#endif
+#ifdef __COMPILE_COMMAND__
+  printf("BENCHMARK: %s \tCFLAGS: %s\nnthreads=%d\n", __BASE_FILE__, __COMPILE_COMMAND__, nthreads);
+#endif
+
+#ifdef LIKWID_PERFMON
+  LIKWID_MARKER_INIT;
+#pragma omp parallel
+  {
+    LIKWID_MARKER_REGISTER("Compute");
+  }
+#endif
+
+  long long dt;
+  if (compressed)
+  {
+    if (symmetric)
+    {
 #ifndef HYPER
       graph<compressedSymmetricVertex> G =
-        readCompressedGraph<compressedSymmetricVertex>(iFile,symmetric,mmap); //symmetric graph
+          readCompressedGraph<compressedSymmetricVertex>(iFile, symmetric, mmap); // symmetric graph
 #else
       hypergraph<compressedSymmetricVertex> G =
-        readCompressedHypergraph<compressedSymmetricVertex>(iFile,symmetric,mmap); //symmetric graph
+          readCompressedHypergraph<compressedSymmetricVertex>(iFile, symmetric, mmap); // symmetric graph
 #endif
-      Compute(G,P);
-      for(int r=0;r<rounds;r++) {
+      Compute(G, 0, max_iter);
+      for (int r = 0; r < rounds; r++)
+      {
         startTime();
-        Compute(G,P);
+        Compute(G, 0, max_iter);
         nextTime("Running time");
       }
       G.del();
-    } else {
+    }
+    else
+    {
 #ifndef HYPER
       graph<compressedAsymmetricVertex> G =
-        readCompressedGraph<compressedAsymmetricVertex>(iFile,symmetric,mmap); //asymmetric graph
+          readCompressedGraph<compressedAsymmetricVertex>(iFile, symmetric, mmap); // asymmetric graph
 #else
       hypergraph<compressedAsymmetricVertex> G =
-        readCompressedHypergraph<compressedAsymmetricVertex>(iFile,symmetric,mmap); //asymmetric graph
+          readCompressedHypergraph<compressedAsymmetricVertex>(iFile, symmetric, mmap); // asymmetric graph
 #endif
-      Compute(G,P);
-      if(G.transposed) G.transpose();
-      for(int r=0;r<rounds;r++) {
+      Compute(G, 0, max_iter);
+      if (G.transposed)
+        G.transpose();
+      for (int r = 0; r < rounds; r++)
+      {
         startTime();
-        Compute(G,P);
+        Compute(G, 0, max_iter);
         nextTime("Running time");
-        if(G.transposed) G.transpose();
+        if (G.transposed)
+          G.transpose();
       }
       G.del();
     }
-  } else {
-    if (symmetric) {
+  }
+  else
+  {
+    if (symmetric)
+    {
 #ifndef HYPER
       graph<symmetricVertex> G =
-        readGraph<symmetricVertex>(iFile,compressed,symmetric,binary,mmap); //symmetric graph
+          readGraph<symmetricVertex>(iFile, compressed, symmetric, binary, mmap); // symmetric graph
 #else
       hypergraph<symmetricVertex> G =
-        readHypergraph<symmetricVertex>(iFile,compressed,symmetric,binary,mmap); //symmetric graph
+          readHypergraph<symmetricVertex>(iFile, compressed, symmetric, binary, mmap); // symmetric graph
 #endif
-      Compute(G,P);
-      for(int r=0;r<rounds;r++) {
-        startTime();
-        Compute(G,P);
-        nextTime("Running time");
+      // Compute(G,P);
+
+      auto nedges = G.m;
+
+      for (int nr = 0; nr < rounds; nr++)
+      {
+        for (int r = 0; r < nroots; r++)
+        {
+          timer.start();
+#ifdef LIKWID_PERFMON
+#pragma omp parallel
+          {
+            LIKWID_MARKER_START("Compute");
+          }
+#endif
+#ifdef USEM5OPS
+          m5_reset_stats(0, 0);
+#endif
+          conv_iter = Compute(G, roots[r], max_iter);
+#ifdef USEM5OPS
+          m5_dump_stats(0, 0);
+#endif
+#ifdef LIKWID_PERFMON
+#pragma omp parallel
+          {
+            LIKWID_MARKER_STOP("Compute");
+          }
+#endif
+          timer.stop();
+          const auto iter_time = timer.read_latest();
+          std::printf("key=%lu root=%lu nthreads=%lu nedges=%d time=%6.5e TEPS=%6.5e iter=%d\n",
+                      r, roots[r], nthreads,
+                      nedges, iter_time / 1e9, (1.0 * nedges / iter_time) * 1e9,
+                      conv_iter);
+        }
       }
+      timer.print_stats("driver", "TEPS", nedges);
       G.del();
-    } else {
+    }
+    else
+    {
 #ifndef HYPER
       graph<asymmetricVertex> G =
-        readGraph<asymmetricVertex>(iFile,compressed,symmetric,binary,mmap); //asymmetric graph
+          readGraph<asymmetricVertex>(iFile, compressed, symmetric, binary, mmap); // asymmetric graph
 #else
       hypergraph<asymmetricVertex> G =
-        readHypergraph<asymmetricVertex>(iFile,compressed,symmetric,binary,mmap); //asymmetric graph
+          readHypergraph<asymmetricVertex>(iFile, compressed, symmetric, binary, mmap); // asymmetric graph
 #endif
-      Compute(G,P);
-      if(G.transposed) G.transpose();
-      for(int r=0;r<rounds;r++) {
-        startTime();
-        Compute(G,P);
-        nextTime("Running time");
-        if(G.transposed) G.transpose();
+      // Compute(G,P);
+      auto nedges = G.m;
+
+      if (G.transposed)
+        G.transpose();
+
+      for (int nr = 0; nr < warmup; nr++)
+      {
+        for (int r = 0; r < nroots; r++)
+        {
+
+          conv_iter = Compute(G, roots[r], max_iter);
+
+          if (G.transposed)
+            G.transpose();
+        }
       }
+
+      for (int nr = 0; nr < rounds; nr++)
+      {
+        for (int r = 0; r < nroots; r++)
+        {
+          timer.start();
+#ifdef LIKWID_PERFMON
+#pragma omp parallel
+          {
+            LIKWID_MARKER_START("Compute");
+          }
+#endif
+#ifdef USEM5OPS
+          m5_reset_stats(0, 0);
+#endif
+          conv_iter = Compute(G, roots[r], max_iter);
+#ifdef USEM5OPS
+          m5_dump_stats(0, 0);
+#endif
+#ifdef LIKWID_PERFMON
+#pragma omp parallel
+          {
+            LIKWID_MARKER_STOP("Compute");
+          }
+#endif
+          timer.stop();
+          const auto iter_time = timer.read_latest();
+          std::printf("key=%lu root=%lu nthreads=%lu nedges=%d time=%6.5e [%s] TEPS=%6.5e iter=%d\n",
+                      r, roots[r], nthreads,
+                      nedges,
+                      clock > 0 ? 1.0 * clock*iter_time : iter_time / 1e9,
+                      clock > 0 ? "cy" : "s",
+                      (1.0 * nedges / iter_time) * 1e9,
+                      conv_iter);
+          if (G.transposed)
+            G.transpose();
+        }
+      }
+      timer.print_stats("driver", "TEPS", nedges, nthreads, clock);
       G.del();
     }
   }
+#ifdef LIKWID_PERFMON
+  LIKWID_MARKER_CLOSE;
+#endif
 }
 #endif
diff --git a/ligra/timer.hpp b/ligra/timer.hpp
new file mode 100644
index 0000000..c7e93b7
--- /dev/null
+++ b/ligra/timer.hpp
@@ -0,0 +1,95 @@
+#ifndef TIMER_HPP
+#define TIMER_HPP
+
+#include <cmath>
+#include <string>
+#include <vector>
+#include <time.h>
+
+namespace vec500::benchmarks {
+
+using namespace vec500;
+
+template <typename T>
+inline T get_nanoseconds(const struct timespec &t1, const struct timespec &t0) {
+    return static_cast<T> ((t1.tv_sec - t0.tv_sec) * 1e9 + (t1.tv_nsec - t0.tv_nsec));
+}
+
+template <typename T>
+struct Timer {
+
+    Timer(int N=64) {
+        nanos.reserve(N);
+    }
+    inline void start() {
+        clock_gettime(CLOCK_THREAD_CPUTIME_ID, &t0);
+    }
+    inline void stop() {
+        clock_gettime(CLOCK_THREAD_CPUTIME_ID, &t1);
+        nanos.push_back(get_nanoseconds<T>(t1,t0));
+    }
+    inline T read_latest() const {
+        T e;
+        if(!nanos.empty())
+            e = nanos.back();
+        return e;
+    }
+    inline void gettime(struct timespec &st) const {
+        clock_gettime(CLOCK_THREAD_CPUTIME_ID, &st);
+    }
+    void print_stats(const std::string &name, const std::string &unit, const T &work, int nthreads=1, float clock=0.0) const {
+        T min = nanos[0];
+        T max = nanos[0];
+        T sum = nanos[0];
+        double mean  = 0.0;
+        double sdev  = 0.0;
+        double inv_sum   = (double)1.0/nanos[0];
+        double inv_hmean = 0.0;
+        double inv_sdev  = 0.0;
+        const auto N = nanos.size();
+        for (int k = 1; k < N; k++) {
+            sum += nanos[k];
+            inv_sum += (double)1.0/nanos[k];
+            min = nanos[k] < min ? nanos[k] : min;
+            max = nanos[k] > max ? nanos[k] : max;
+        }
+        mean = (double) sum / N;
+        inv_hmean = inv_sum / N;
+        for (int k = 0; k < N; k++) {
+            sdev += (nanos[k]-mean)*(nanos[k]-mean);
+            inv_sdev += (((double)1.0/nanos[k])-inv_hmean)*(((double)1.0/nanos[k])-inv_hmean);
+        }
+        if (N>1) {
+            sdev = std::sqrt(sdev/(N-1));
+            inv_sdev = std::sqrt(inv_sdev/(N-1));
+        }
+
+        std::printf("  %s Performance [G%s/s] min=%4.3e max=%4.3e mean=%4.3e std=%4.3e\n"
+                    "  %s Time [s] min=%6.5e max=%6.5e mean=%6.5e time=%6.5e [%s] std=%6.5e N=%lu nthreads=%d work=%d \n",
+                name.c_str(),
+                unit.c_str(),
+                (double) work / max,
+                (double) work / min,
+                (double) work * inv_hmean,
+                (double) work * inv_sdev,
+                name.c_str(),
+                min*1.0E-09,
+                max*1.0E-09,
+                mean*1.0E-09,
+                clock > 0 ? 1.0 * clock*mean : mean*1.0E-09,
+                clock > 0 ? "cy" : "s",
+                sdev/mean,
+                N,
+                nthreads,
+                work
+            );
+    }
+    struct timespec t0;
+    struct timespec t1;
+    std::vector<T> nanos;
+
+};
+
+}
+
+#endif // TIMER_HPP
diff --git a/ligra/utils.h b/ligra/utils.h
index 648888f..de9b2d8 100644
--- a/ligra/utils.h
+++ b/ligra/utils.h
@@ -23,6 +23,7 @@
 // WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #ifndef UTIL_H
 #define UTIL_H
+#include <cstdint>
 #include <iostream>
 #include <fstream>
 #include <stdlib.h>
@@ -353,6 +354,7 @@ inline int xaddi(int *variable, int value) {
 // this should work with pointer types, or pairs of integers
 template <class ET>
 inline ET xadd(ET *variable, ET value) {
+#if defined(__x86_64__)
   if (sizeof(ET) == 8) {
     return xaddl((long*)variable,(long)value);
   } else if (sizeof(ET) == 4) {
@@ -361,6 +363,10 @@ inline ET xadd(ET *variable, ET value) {
     std::cout << "xadd bad length" << std::endl;
     abort();
   }
+#else
+  std::cout << "Not implemented!" << std::endl;
+  abort();
+#endif
 }
 
 inline uint hashInt(uint a) {
diff --git a/utils/rMatGraph.C b/utils/rMatGraph.C
index 57b2508..f383094 100644
--- a/utils/rMatGraph.C
+++ b/utils/rMatGraph.C
@@ -77,12 +77,16 @@ int parallel_main(int argc, char* argv[]) {
   pair<intT,char*> in = P.sizeAndFileName();
   uintT n = in.first;
   char* fname = in.second;
-  double a = P.getOptionDoubleValue("-a",.5);
-  double b = P.getOptionDoubleValue("-b",.1);
-  double c = P.getOptionDoubleValue("-c", b);
-  uintT m = P.getOptionLongValue("-m", 10*n);
+  double a = P.getOptionDoubleValue("-a", 0.57);
+  double b = P.getOptionDoubleValue("-b", 0.19);
+  double c = P.getOptionDoubleValue("-c", 0.19);
+  uintT m = P.getOptionLongValue("-m", 16*n);
   intT seed = P.getOptionLongValue("-r", 1);
   bool sym = P.getOptionValue("-s");
+
+  std::printf("a=%.3f b=%.3f c=%.3f N=%lu M=%lu seed=%lu sym=%i file=%s\n",
+    a, b, c, n, m, seed, sym ? 1 : 0, fname);
+
   edgeArray<uintT> EA = edgeRmat<uintT>(n, m, seed, a, b, c);
   graph<uintT> G = graphFromEdges<uintT>(EA, sym);
   EA.del();
